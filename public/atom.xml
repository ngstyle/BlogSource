<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Scorp31io's Blog]]></title>
  <subtitle><![CDATA[The best time to plant a tree is ten years ago and it is now]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ngstyle.github.io//"/>
  <updated>2015-11-23T14:26:07.677Z</updated>
  <id>http://ngstyle.github.io//</id>
  
  <author>
    <name><![CDATA[Scorp31io]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android Handler详解]]></title>
    <link href="http://ngstyle.github.io/2015/06/10/handler-detail/"/>
    <id>http://ngstyle.github.io/2015/06/10/handler-detail/</id>
    <published>2015-06-10T15:00:49.000Z</published>
    <updated>2015-11-23T14:26:07.677Z</updated>
    <content type="html"><![CDATA[<h3 id="Android为什么要设计只能通过Handler机制更新UI？">Android为什么要设计只能通过Handler机制更新UI？</h3><p>最根本的问题就是解决多线程并发问题，假设如果在一个Activity当中，有多个线程去更新UI,并且没有加锁机制，那将造成界面更新错乱。倘若如果对更新UI的操作都进行加锁处理又将导致性能的下降。</p>
<p>处于对以上问题的考虑，android 给我们提供了一套UI更新的机制，我们只需遵循这样的机制就可以了，不用担心多线程的问题，更新UI的操作都是在主线程的消息队列中去轮询处理的。</p>
<h3 id="Handler_原理是什么？">Handler 原理是什么？</h3><p>Android上一个应用的入口是ActivityThread，和普通的java类一样，入口是一个main方法。在其中会给我们创建一个Looper，创建Looper的过程中会创建一个MessageQueue对象。<br><a id="more"></a></p>
<blockquote>
<p>ActivityThread main()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SamplingProfilerIntegration.start();  </span><br><span class="line">  </span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">        Environment.initForCurrentUser();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore  </span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());  </span><br><span class="line">  </span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);  </span><br><span class="line">  </span><br><span class="line">        Looper.prepareMainLooper();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建ActivityThread实例  </span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();  </span><br><span class="line">        thread.attach(<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            sMainThreadHandler = thread.getHandler();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        AsyncTask.init();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;  </span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Looper.loop();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Looper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Looper对象</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建MessageQueue 对象</span></span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mRun = <span class="keyword">true</span>;</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// msg 回传给自己</span></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Handler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ······</span><br><span class="line">     </span><br><span class="line">     mLooper = Looper.myLooper();</span><br><span class="line">     </span><br><span class="line">     ······</span><br><span class="line">     mQueue = mLooper.mQueue;</span><br><span class="line">     mCallBack = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">     MessageQueue queue = mQueue;</span><br><span class="line">     <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">         RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                 <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">         Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">     msg.target = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">         msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">         handleCallback(msg);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         handleMessage(msg);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>Looper(消息载体)：内部包含一个消息队列也就是MessageQueue，所有的Handler发送的消息都走向这个消息队列，Looper.loop方法，就是一个死循环，不断的从MessageQueue取消息，有消息就处理消息，没有消息就阻塞。</li>
<li>MessageQueue(消息容器)：一个消息队列，可以添加消息。</li>
<li>Handler内部和Looper进行关联，也就是说在Handler中可以找到Looper，找到了Looper也就找到了MessageQueue，在Handler中发送消息其实就是向MessageQueue队列中发送消息，Looper负责接收Handler发送的消息，并直接把消息回传给Handler自己。</li>
</ol>
<h3 id="指定线程处理消息_—_handleMessage">指定线程处理消息 — handleMessage</h3><p>在Handler构造方法中可指定某个线程Looper来作为本身消息的轮询处理。其中HandlerThread继承自Thread，维护了一个所在线程的一个Looper，handlerThread.getLooper()即可获得子线程的一个Looper。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper())&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"子线程创建的handler在: "</span> + Thread.currentThread() + <span class="string">" 接收消息"</span>);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		handler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handler thread"</span>);</span><br><span class="line">handlerThread.start();</span><br><span class="line"></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper())&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"主线程创建的handler在: "</span> + Thread.currentThread() + <span class="string">" 接收消息"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handler.sendEmptyMessage(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Android中更新UI的几种方法">Android中更新UI的几种方法</h3><ul>
<li><p>runOnUIThread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>handler post</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>handler sendMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>view post</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Causes the Runnable to be added to the message queue.</span><br><span class="line"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> action The Runnable that will be executed.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> Returns true if the Runnable was successfully placed in to the</span><br><span class="line"> *         message queue.  Returns false on failure, usually because the</span><br><span class="line"> *         looper processing the message queue is exiting.</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume that post will succeed later</span></span><br><span class="line">    ViewRootImpl.getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Android为什么要设计只能通过Handler机制更新UI？">Android为什么要设计只能通过Handler机制更新UI？</h3><p>最根本的问题就是解决多线程并发问题，假设如果在一个Activity当中，有多个线程去更新UI,并且没有加锁机制，那将造成界面更新错乱。倘若如果对更新UI的操作都进行加锁处理又将导致性能的下降。</p>
<p>处于对以上问题的考虑，android 给我们提供了一套UI更新的机制，我们只需遵循这样的机制就可以了，不用担心多线程的问题，更新UI的操作都是在主线程的消息队列中去轮询处理的。</p>
<h3 id="Handler_原理是什么？">Handler 原理是什么？</h3><p>Android上一个应用的入口是ActivityThread，和普通的java类一样，入口是一个main方法。在其中会给我们创建一个Looper，创建Looper的过程中会创建一个MessageQueue对象。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://ngstyle.github.io/tags/Android/"/>
    
      <category term="handler" scheme="http://ngstyle.github.io/tags/handler/"/>
    
      <category term="Android" scheme="http://ngstyle.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当乐软件详情页实现]]></title>
    <link href="http://ngstyle.github.io/2015/06/08/stickylayout/"/>
    <id>http://ngstyle.github.io/2015/06/08/stickylayout/</id>
    <published>2015-06-08T14:43:39.000Z</published>
    <updated>2015-11-23T14:26:07.684Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/ngstyle/StickyLayout" target="_blank" rel="external">源码下载地址</a></p>
<blockquote>
<p>基于 <a href="http://blog.csdn.net/lmj623565791/article/details/43649913" target="_blank" rel="external">Android 自定义控件 轻松实现360软件详情页</a></p>
</blockquote>
<p><img src="https://github.com/ngstyle/StickyLayout/raw/master/screenrecord.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/ngstyle/StickyLayout" target="_blank" rel="external">源码下载地址</a></p>
<blockquote>
<p>基于 <a href="http://blog.c]]>
    </summary>
    
      <category term="Android" scheme="http://ngstyle.github.io/tags/Android/"/>
    
      <category term="自定义控件" scheme="http://ngstyle.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
      <category term="Android" scheme="http://ngstyle.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[种一棵树最好的时间是十年前，其次是现在]]></title>
    <link href="http://ngstyle.github.io/2015/06/05/just-now/"/>
    <id>http://ngstyle.github.io/2015/06/05/just-now/</id>
    <published>2015-06-05T07:34:26.000Z</published>
    <updated>2015-11-23T14:26:07.679Z</updated>
    <content type="html"><![CDATA[<p>“我每一次挥动胳膊，都可以感觉到肌肉的震颤，我很确信，大重量的卧推一定会让我的胸大肌发育，我知道拼了命的锻炼，真的可以给我带来回报。但是其他很多东西，你没有任何拼命的方向，甚至是拼了命也没用，说不清。我喜欢健身房，喜欢这个地方，就像家一样。”</p>
<p>这个臂围40的哥们慢悠悠的讲这句话的时候，我心里还是咯噔了一下。</p>
<p>故事的剧情简单明了，女朋友刚刚实习，被温柔多金的经理所吸引，抛下了相伴三年的哥们。</p>
<p>按照剧情发展，故事应该是这个卧推110kg的哥们揭露出经理的邪恶与阴险，英勇的从经理手中抢回女朋友从此过上幸福的生活，但是哥们跟我说，比人家差太多了：帅，体贴，父亲是公司大股东，已经给姑娘做好了很多规划……而我从很努力从农村考到县城再到大学，进了学校之后发现自己什么都不懂，不懂人情世故，不懂表达和交流，对这个花花世界其实一无所知，很少问爸妈怕给他们带来更多的烦恼，就像一个傻瓜一样成天骗自己All is well。<br><a id="more"></a></p>
<p>我这才明白过来这原来不是一个真爱大战反派的故事，这个故事比北爱还要苦涩，还要直截了当。</p>
<p>“如果哪里真的可以卖命，或者是灵魂还是人格无论什么乱七八糟的东西，请联系我。”哥们和我说他真不是开玩笑，以前他一直觉得自己拼命，是可以走向成功的，现在想想，自己拼了命的成功达到的不过是别人的起跑线，甚至还不一定够得着。如果兔子都拼命奔跑，乌龟还有什么前进的动力？</p>
<p>直到现实重重的拍打在自己的脸上，才知道仰天大笑三声，吐血三升而亡的感觉。</p>
<p>我突然想起以前一条新闻，讲一个女孩子成绩优异，本可以轻松清北，但从小受留学法国的母亲的影响，参加各种社会活动，然后毅然决定放弃高考，申请了哥大并且成功了。新闻下面附了这个女孩子的照片，挺漂亮，这条新闻也受到各界媒体的转载和褒扬，我不带任何仇优心理的又找到了这条给我留下深刻记忆的评论：</p>
<p>“我没有皇城根下的家，也没有留过洋的爸妈。我只能要着牙拼命学习，在千军万马中挤破头，换来一个国内普通的大学。而我还要拼命努力，才能换来一个普通的人生。但这条新闻把千万个我们这种普通家庭却从没放弃努力的孩子，当成了傻瓜。”</p>
<p> “迷茫时为你点一盏灯，沉沦时敲你一棍，困顿时一顿饱餐，甚至直接为你的一生保驾护航。这样的家境下的人大概很难体会到我的一生，我和我女朋友讲过我曾经为了赚生活费住过桥洞，有一种夏虫不能语冰的感觉。‘和那些少爷们不同，我们光是活着就拼尽全了。’我原本以为，像我这种穷人家的娃，拥有更狂妄的野心，但其实，就像青蛙总把井上的天空当作他野心的全部。我现在更加理解了在狼多肉少的时候，小狼怎么样，完全取决于老狼这种定律。”</p>
<p>至少你要在大时代中做个坚强的小人物，至少在狂欢夜做个自由的舞者。这是我的希望</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>“我每一次挥动胳膊，都可以感觉到肌肉的震颤，我很确信，大重量的卧推一定会让我的胸大肌发育，我知道拼了命的锻炼，真的可以给我带来回报。但是其他很多东西，你没有任何拼命的方向，甚至是拼了命也没用，说不清。我喜欢健身房，喜欢这个地方，就像家一样。”</p>
<p>这个臂围40的哥们慢悠悠的讲这句话的时候，我心里还是咯噔了一下。</p>
<p>故事的剧情简单明了，女朋友刚刚实习，被温柔多金的经理所吸引，抛下了相伴三年的哥们。</p>
<p>按照剧情发展，故事应该是这个卧推110kg的哥们揭露出经理的邪恶与阴险，英勇的从经理手中抢回女朋友从此过上幸福的生活，但是哥们跟我说，比人家差太多了：帅，体贴，父亲是公司大股东，已经给姑娘做好了很多规划……而我从很努力从农村考到县城再到大学，进了学校之后发现自己什么都不懂，不懂人情世故，不懂表达和交流，对这个花花世界其实一无所知，很少问爸妈怕给他们带来更多的烦恼，就像一个傻瓜一样成天骗自己All is well。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://ngstyle.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心路历程" scheme="http://ngstyle.github.io/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
</feed>